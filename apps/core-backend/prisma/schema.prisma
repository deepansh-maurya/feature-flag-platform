// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider         = "prisma-client-js"
  output           = "../generated/prisma"
  connection_limit = 10
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum BillingStatus {
  active
  past_due
  canceled
  frozen
  default
}

enum RoleKey {
  owner
  admin
  developer
  ops
  viewer
  custom
}

enum UserStatus {
  invited
  active
  disabled
}

enum IntegrationProvider {
  POSTHOG
  SEGMENT
  DATADOG
  AMPLITUDE
}

enum IntegrationStatus {
  coming_soon // visible in UI but not functional yet
  active // configured + working
  error // misconfigured or failing
  disabled // explicitly turned off
}

enum SegmentType {
  dynamic // uses rulesJson (traits-based predicate)
  static // uses SegmentMember rows
}

enum ChangeRequestStatus {
  open
  approved
  rejected
  applied
}

enum FlagType {
  boolean
  multivariate
  json
}

enum EnvKey {
  dev
  stage
  prod
}

enum SdkKeyType {
  client
  server
}

enum KeyStatus {
  active
  revoked
  disabled
}

enum AllowlistKind {
  ip
  referrer
}

enum OutboxStatus {
  pending
  sent
  failed
}

enum FlagVersionStatus {
  draft
  active
  superseded
  rolled_back
}

enum TargetType {
  user
  account
  service
}

enum AuditActionType {
  workspace_created
  workspace_updated
  project_created
  project_updated
  flag_created
  flag_updated
  flag_published
  flag_archived
  segment_created
  segment_updated
  member_invited
  member_added
  member_removed
  token_created
  token_revoked
  // add more as needed
}

enum EvalSource {
  web
  ios
  android
  backend
}

enum PlanKey {
  STARTER
  GROWTH
  ENTERPRISE
  DEFAULT
}

enum SubscriptionStatus {
  active
  trialing
  past_due
  grace
  frozen
  canceled
}

enum BillingCycle {
  monthly
  yearly
}

enum WebhookEndpointStatus {
  active
  disabled
}

enum WebhookDeliveryStatus {
  pending
  sent
  failed
}

enum PlanStatus {
  draft
  active
  archived
}

//
// ---------- Core ----------

model Admin {
  id       String   @id @default(uuid())
  passKey  String
  isUsable Boolean? @default(true)
  deviceId String?
}

model Workspace {
  id                 String                 @id @default(uuid())
  name               String
  slug               String                 @unique
  stripeCustomerId   String
  ownerUserId        String                 @unique()
  archivedAt         DateTime?
  owner              User                   @relation("WorkspaceOwner", fields: [ownerUserId], references: [id], onDelete: Restrict)
  planKey            String                 @default("free")
  billingStatus      BillingStatus          @default(active)
  createdAt          DateTime               @default(now())
  updatedAt          DateTime               @updatedAt
  razorpayCustomerId String?
  flags              Flag[]                 @relation("WorkspaceFlags")
  projects           Project[]              @relation("WorkspaceProjects")
  members            WorkspaceMember[]      @relation("WorkspaceMembers")
  invites            Invite[]               @relation("WorkspaceInvites")
  roles              Role[]                 @relation("WorkspaceRoles")
  environment        Environment[]          @relation("WorkspaceEnvironments")
  refreshTokens      RefreshToken[]
  subscriptions      Subscription[]
  invoices           Invoice[]
  usageCounters      UsageCountersMonthly[]
  notification       NotificationSetting?
  webhookEndpoints   WebhookEndpoint[]
  apiTokens          ApiToken[]
  auditLogs          AuditLog[]
  ChangeRequest      ChangeRequest[]
  Segment            Segment[]
  SegmentMember      SegmentMember[]
  SdkKey             SdkKey[]
  OutboxEvent        OutboxEvent[]
  EvalEventRaw       EvalEventRaw[]
  EvalRollupHourly   EvalRollupHourly[]
  EvalRollupDaily    EvalRollupDaily[]
  WebhookDelivery    WebhookDelivery[]
  RateLimit          RateLimit[]
  Session            Session[]
}

model WebhookEvent {
  id        String   @id // Stripe event.id (e.g. "evt_123...")
  createdAt DateTime @default(now())
}

model Project {
  id               String        @id @default(uuid())
  workspaceId      String
  name             String
  key              String?
  langSupport      String
  timeZone         String
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  rolloutPollicies Json
  workspace        Workspace     @relation("WorkspaceProjects", fields: [workspaceId], references: [id], onDelete: Cascade)
  environments     Environment[] @relation("ProjectEnvironments")
  flags            Flag[]        @relation("ProjectFlags")
  segments         Segment[]     @relation("ProjectSegments")
  SdkKey           SdkKey[]

  @@unique([workspaceId, name]) // (workspace_id, key) unique
  @@index([workspaceId])
}

model Environment {
  id          String   @id @default(uuid())
  projectId   String
  key         String // e.g. dev|stage|prod|canary...
  displayName String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  workspaceId String

  workspace Workspace @relation("WorkspaceEnvironments", fields: [workspaceId], references: [id], onDelete: Cascade)
  project   Project   @relation("ProjectEnvironments", fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, key]) // (project_id, key) unique
  @@index([projectId])
}

// ---------- Users & Membership ----------
model User {
  id           String     @id @default(uuid())
  email        String     @unique
  name         String
  passwordHash String?
  isDeleted    Boolean    @default(false)
  externalIdp  String?
  status       UserStatus @default(invited)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  // opposite side of Workspace.owner
  ownedWorkspaces Workspace[] @relation("WorkspaceOwner")

  // other relations to Workspace through join tables
  memberships WorkspaceMember[] @relation("UserMemberships")
  invites     Invite[]          @relation("UserInvitesByEmail")
}

model RefreshToken {
  id          String    @id @default(cuid())
  userId      String
  workspaceId String
  tokenHash   String    @unique
  expiresAt   DateTime
  revokedAt   DateTime?
  createdAt   DateTime  @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([workspaceId])
}

model WorkspaceMember {
  id          String   @id @default(cuid())
  workspaceId String
  userId      String
  roleKey     RoleKey  @default(viewer)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  workspace Workspace @relation("WorkspaceMembers", fields: [workspaceId], references: [id], onDelete: Cascade)
  user      User      @relation("UserMemberships", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, userId])
  @@index([workspaceId, createdAt, id])
}

// ---------- Invites ----------
model Invite {
  id              String   @id @default(uuid())
  workspaceId     String
  email           String
  roleKey         RoleKey  @default(viewer)
  tokenHash       String   @unique
  status          String   @default("pending")
  expiresAt       DateTime
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  invitedByUserId String

  workspace   Workspace @relation("WorkspaceInvites", fields: [workspaceId], references: [id], onDelete: Cascade)
  invitedUser User?     @relation("UserInvitesByEmail", fields: [email], references: [email])

  @@unique([workspaceId, email])
  @@index([workspaceId])
}

// ---------- Custom Roles ----------
model Role {
  id          String   @id @default(uuid())
  workspaceId String
  key         String
  name        String
  permissions Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  workspace Workspace @relation("WorkspaceRoles", fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, key])
  @@index([workspaceId])
}

/////////////////////////////////////

// =======================================
// Enums
// =======================================

// =======================================
// Core
// =======================================

// =======================================
// Feature Flags / Versions / Segments
// =======================================

model Flag {
  id          String   @id @default(uuid())
  projectId   String
  workspaceId String
  key         String
  type        FlagType
  description String?
  archived    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?

  workspace Workspace       @relation("WorkspaceFlags", fields: [workspaceId], references: [id], onDelete: Cascade)
  project   Project         @relation("ProjectFlags", fields: [projectId], references: [id], onDelete: Cascade)
  versions  FlagVersion[]   @relation("FlagVersions")
  changes   ChangeRequest[] @relation("FlagChangeRequests")

  // 1-1 metadata (display name + tags)
  flagMeta FlagMeta?

  @@unique([projectId, key])
  @@index([workspaceId])
  @@index([projectId])
}

model FlagMeta {
  flagId String   @id
  name   String
  tags   String[]

  flag Flag @relation(fields: [flagId], references: [id], onDelete: Cascade)
}

model FlagVersion {
  id        String            @id @default(uuid())
  flagId    String
  version   Int
  comment   String?
  status    FlagVersionStatus @default(draft)
  createdBy String
  createdAt DateTime          @default(now())

  flag       Flag            @relation("FlagVersions", fields: [flagId], references: [id], onDelete: Cascade)
  envConfigs FlagEnvConfig[]

  @@unique([flagId, version])
  @@index([flagId])
}

model FlagEnvConfig {
  id            String  @id @default(uuid())
  flagVersionId String
  envKey        EnvKey
  enabled       Boolean
  variantKey    String?
  jsonValue     Json?
  rollout       Int? // 0..100
  rules         Json?

  flagVersion FlagVersion @relation(fields: [flagVersionId], references: [id], onDelete: Cascade)

  @@unique([flagVersionId, envKey])
  @@index([envKey])
}

model ChangeRequest {
  id          String              @id @default(uuid())
  flagId      String
  workspaceId String
  envKey      String
  fromVersion Int?
  toVersion   Int
  status      ChangeRequestStatus @default(open)
  createdBy   String
  reviewerId  String?
  comment     String?
  approvedAt  DateTime?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  flag      Flag      @relation("FlagChangeRequests", fields: [flagId], references: [id], onDelete: Cascade)

  @@index([workspaceId])
  @@index([flagId, envKey, status])
}

model Segment {
  id             String      @id @default(uuid())
  workspaceId    String
  projectId      String? // allow workspaceâ€‘level segments; null = workspace-global
  key            String // machine key (used in RuleSet JSON)
  name           String // display name in UI
  description    String?
  type           SegmentType
  rulesJson      Json? // required when type=dynamic; null for static
  isArchived     Boolean     @default(false)
  createdBy      String
  updatedBy      String?
  definitionHash String? // hash(rulesJson) for cache/CDN invalidation
  compiledBlob   Bytes? // optional precompiled predicate (regex/semver/cidr)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  workspace Workspace       @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  project   Project?        @relation("ProjectSegments", fields: [projectId], references: [id], onDelete: Cascade)
  members   SegmentMember[]

  @@unique([workspaceId, projectId, key]) // keeps key unique per scope
  @@index([workspaceId, name])
  @@index([workspaceId, isArchived])
}

model SegmentMember {
  segmentId   String
  workspaceId String
  targetType  TargetType // user|account|service
  targetKey   String // e.g., userId/email/accountId/serviceId
  addedBy     String?
  addedAt     DateTime   @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  segment   Segment   @relation(fields: [segmentId], references: [id], onDelete: Cascade)

  @@id([segmentId, targetType, targetKey])
  @@index([workspaceId, targetType, targetKey])
  @@index([segmentId])
}

model FlagRuleSet {
  id            String    @id @default(uuid())
  workspaceId   String
  projectId     String
  flagId        String
  envKey        String // dev|stage|prod
  version       Int
  status        String    @default("draft") // draft|active|archived
  rules         Json // ordered list with allow/deny + segment refs
  defaultVar    String
  killswitch    Boolean   @default(false)
  prerequisites Json? // [{flagKey, variations:[...]}]
  salt          String // for sticky hashing
  configHash    String? // ETag for CDN/polling
  createdBy     String
  publishedBy   String?
  publishedAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([flagId, envKey, version])
  @@index([workspaceId, projectId, flagId, envKey, status])
}

model FlagOverride {
  id           String     @id @default(uuid())
  workspaceId  String
  projectId    String
  flagId       String
  envKey       String
  targetType   TargetType // user|account|service
  targetKey    String
  mode         String // allow|deny|force
  variationKey String?
  expiresAt    DateTime?
  createdBy    String?
  createdAt    DateTime   @default(now())

  @@index([workspaceId, flagId, envKey, targetType, targetKey])
}

model FlagEvaluation {
  id          String   @id @default(uuid())
  flagId      String
  envKey      String
  userId      String
  enabled     Boolean
  variant     String?
  ruleMatched String?
  evaluatedAt DateTime @default(now())

  @@index([flagId, envKey, evaluatedAt])
  @@index([userId])
}

//////////////////////////////

// =============================
// Enums
// =============================

// =============================
// SDK Keys (for SDKs)
// =============================
model SdkKey {
  id          String     @id @default(uuid())
  projectId   String
  workspaceId String
  envKey      String
  type        SdkKeyType
  keyHash     String
  status      KeyStatus  @default(active)
  lastUsedAt  DateTime?
  rotatedAt   DateTime?
  createdBy   String
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  project   Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([workspaceId])
  @@index([projectId, envKey, type, status])
}

// =============================
// API Tokens (admin/CLI)     
// =============================
model ApiToken {
  id          String    @id @default(uuid())
  workspaceId String
  tokenHash   String    @unique
  scopes      Json
  status      String    @default("active") // keep string for flexibility
  lastUsedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // link back to Workspace
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, status])
}

// =============================
// Outbox Events (reliable cache updates)    
// =============================
model OutboxEvent {
  id          String       @id @default(uuid())
  topic       String // e.g. "flag.updated"
  payloadJson Json
  status      OutboxStatus @default(pending)
  workspaceId String
  attempts    Int          @default(0)
  nextRetryAt DateTime?
  createdAt   DateTime     @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  // Optional scoping for convenience (kept scalar to avoid extra relations)
  projectId String?

  @@index([status, nextRetryAt])
  @@index([topic])
}

///////////////////////////

// =============================
// Enums
// =============================

// =============================
// Audit (append-only)   
// =============================
model AuditLog {
  id          String  @id @default(uuid())
  workspaceId String
  projectId   String?
  envKey      String? // "dev" | "stage" | "prod" | ...
  entityType  String // "flag" | "targeting" | "project" | ...
  entityId    String // flagId, ruleId, projectId, etc.
  entityKey   String? // "dark_mode_v2" helpful for UI labels

  actionType  AuditActionType
  title       String // short: "Flag toggled ON"
  description String? // optional long text for details

  // who
  actorUserId String
  actorName   String

  // snapshots
  beforeJson Json?
  afterJson  Json?

  // misc
  metadata Json? // IP, UA, requestId, etc.

  createdAt DateTime  @default(now())
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, createdAt])
  @@index([workspaceId, projectId, envKey, createdAt])
  @@index([workspaceId, entityType, entityId, createdAt])
  @@index([workspaceId, actionType, createdAt])
  @@index([workspaceId, actorUserId, createdAt])
}

// =============================
// Evaluation events (raw, optional for MVP)
// =============================
model EvalEventRaw {
  id          String     @id @default(uuid())
  workspaceId String
  ts          DateTime
  projectId   String
  envKey      String
  flagKey     String
  variant     String
  userKeyHash String
  source      EvalSource

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId])
  @@index([projectId, envKey, flagKey, ts])
}

// =============================
// Rollups (hourly / daily)
// =============================

model EvalRollupHourly {
  dateHour    DateTime
  projectId   String
  workspaceId String
  envKey      String
  flagKey     String
  variant     String
  count       Int      @default(0)

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([dateHour, projectId, envKey, flagKey, variant])
  @@index([workspaceId])
}

model EvalRollupDaily {
  date        DateTime
  projectId   String
  workspaceId String
  envKey      String
  flagKey     String
  variant     String
  count       Int      @default(0)

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([date, projectId, envKey, flagKey, variant])
  @@index([workspaceId])
}

/////////////////////////////////

// =============================
// Enums
// =============================

// =============================
// Subscriptions (per workspace)
// =============================
model Subscription {
  id                 String             @id @default(uuid())
  workspaceId        String
  planKey            PlanKey
  status             SubscriptionStatus @default(active)
  periodStart        DateTime
  periodEnd          DateTime
  billingCycle       BillingCycle
  cancelAtPeriodEnd  Boolean            @default(false)
  cancelsAt          DateTime?
  razorpayCustomerId String?
  razorpaySubId      String?            @unique
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, status])
}

// =============================
// Invoices (per workspace)
// =============================
model Invoice {
  id              String   @id @default(uuid())
  workspaceId     String
  stripeInvoiceId String?  @unique
  amountCents     Int
  currency        String   @default("USD")
  status          String
  periodStart     DateTime
  periodEnd       DateTime
  pdfUrl          String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, status])
}

// =============================
// Monthly Usage Counters
// =============================
// Use first day of month UTC in `month`, e.g., 2025-08-01T00:00:00Z
model UsageCountersMonthly {
  workspaceId String
  month       DateTime
  apiRequests Int      @default(0)
  activeFlags Int      @default(0)
  members     Int      @default(0)
  envs        Int      @default(0)
  updatedAt   DateTime @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, month])
}

//////////////////////////////////////////////

// ============ Enums ============

// ============ Notification Settings ============
model NotificationSetting {
  workspaceId     String   @id
  emailAlerts     Boolean  @default(false)
  webhookEnabled  Boolean  @default(false)
  slackWebhookUrl String?
  updatedAt       DateTime @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
}

// ============ Webhook Endpoints ============
model WebhookEndpoint {
  id          String                @id @default(uuid())
  workspaceId String
  url         String
  secret      String
  events      String[]
  status      WebhookEndpointStatus @default(active)
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt

  workspace       Workspace         @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  WebhookDelivery WebhookDelivery[]

  @@index([workspaceId, status])
}

// ============ Webhook Deliveries ============
model WebhookDelivery {
  id           String                @id @default(uuid())
  endpointId   String
  workspaceId  String
  eventType    String
  payloadJson  Json
  status       WebhookDeliveryStatus @default(pending)
  responseCode Int?
  attempts     Int                   @default(0)
  nextRetryAt  DateTime?
  createdAt    DateTime              @default(now())

  workspace Workspace       @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  endpoint  WebhookEndpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)

  @@index([workspaceId])
}

//////////////////////////////////

// =============================
// Rate Limits (forensics snapshot)
// Use Redis for real-time; DB is optional audit trail.
// =============================
model RateLimit {
  key         String
  workspaceId String
  windowStart DateTime
  count       Int      @default(0)
  recordedAt  DateTime @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([key, windowStart, workspaceId])
  @@index([workspaceId])
}

// =============================
// Sessions (cookie-based sessions)
// If you use JWT-only, you can skip this table.
// =============================
model Session {
  sessionId    String   @id
  userId       String
  workspaceId  String
  expiresAt    DateTime
  metadataJson Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([workspaceId])
  @@index([expiresAt])
}

// =============================
// Migrations (only if NOT using Prisma Migrate)
// Prisma already manages its own migration history table.
// Use this only if you run custom SQL migrations outside Prisma.
// =============================
model AppMigration {
  id          String   @id @default(uuid())
  version     String   @unique // e.g. "2025-08-15T10-23-add-xyz"
  checksum    String // hash of the SQL file / content
  description String?
  appliedAt   DateTime @default(now())
  tookMs      Int?
  success     Boolean  @default(true)
}

// ============================================
// pricing plan models
// ==========================================

model Plan {
  id          String     @id @default(uuid())
  key         String     @unique // e.g., "starter", "pro"
  name        String
  description String?
  status      PlanStatus @default(draft)
  trialDays   Int        @default(0)
  sortOrder   Int        @default(0)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  prices   Price[]
  features PlanFeature[]
  limits   PlanLimit[]
}

model Price {
  id                String       @id @default(uuid())
  planId            String
  recurringInterval BillingCycle
  currency          String       @default("usd")
  unitAmountCents   Int
  stripeProductId   String?
  stripePriceId     String?
  isMetered         Boolean      @default(false)
  meterKey          String? // e.g. "evaluations" (for overage later)
  active            Boolean      @default(true)
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  plan Plan @relation(fields: [planId], references: [id])
}

model PlanFeature {
  id      String  @id @default(uuid())
  planId  String
  key     String // e.g., "experiments", "sso"
  enabled Boolean @default(true)
  notes   String?

  plan Plan @relation(fields: [planId], references: [id])

  @@unique([planId, key])
}

model PlanLimit {
  id       String @id @default(uuid())
  planId   String
  resource String // e.g., "projects", "flags", "segments"
  soft     Int?
  hard     Int?

  plan Plan @relation(fields: [planId], references: [id])

  @@unique([planId, resource])
}
